# 💡**문제 분석 요약**

n 위치에서 할 수 있는 액션은 총 3개로,

- 2*n
- n + 1
- n - 1

BFS 를 3개의 액션으로 돌려서 탐색하되, 방문한 노드는 스킵한다.

# 💡**알고리즘 설계**

n=k 인 경우,

0 을 출력함.

n ≠ k 인 경우,

BFS 함수(3 개의 액션을 for 문으로 탐색하는) 실행

# 💡코드

```java
package week2.day5;
import java.util.*;
import java.io.*;

public class P1697 {
  static BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));
  static int visited[];

  public static void main(String[] args) throws Exception {
    StringTokenizer st = new StringTokenizer(bf.readLine());

    int n = Integer.parseInt(st.nextToken());
    int k = Integer.parseInt(st.nextToken());

    visited = new int[100001];
    if (n == k)
      System.out.println(0);
    else
      System.out.println(bfs(n, k));
  }

  private static int bfs(int n, int k) {
    Queue<Integer> q = new LinkedList<>();
    q.offer(n);
    visited[n] = 1; //방문 체크

    int result = 0;
    while (!q.isEmpty()) {
      int front = q.poll();

      for (int i = 0; i < 3; i++) {
        int next;
        if (i == 0) {
          next = front + 1;
        } else if (i == 1) {
          next = front - 1;
        } else {
          next = front * 2;
        }
        //목표값 k와 같은지 확인
        if (next == k) {
          return  visited[front];
        }
        if (next >= 0 && next < visited.length && visited[next] == 0) {
          q.add(next);
          visited[next] = visited[front] + 1;
        }
      }
    }
    return -1;//사실상 도달 불가

  }
}

```

# 💡시간복잡도

next 값과 n 값 내에 k값이 있는 것이고, 각각의 값을 모두 하나의 node로 생각한다면,

전체 노드의 개수 = m 이라 할때,

최악의 경우, 모든 노드, 간선을 다 돌아야하므로

T(m) = O(m)

# 💡 틀린 이유

- n = k 인경우, 0이 출력되도록 설계하지 않았다.
- 3개의 노드를 탐색하는 방법이 이전까지와는 달라 생소했다

# 💡 느낀점 or 기억할정보